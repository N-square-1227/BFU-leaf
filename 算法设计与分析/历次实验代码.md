# 常见WA

数组开得太小

min/maxi等值设置的太小，或是可能出现负数的情况却用了负数作为依据

输出多输出/少输出了空格/换行符

vector换成大int数组

int类型换long，long long

```c++
typedef long long LL;
```



# 实验一 · 暴力，枚举，dfs

## A 枚举[n,m]特殊回文数

`二进制获取位数`

思路：

字符串比较肯定不行，**totring方法最多能用一次，如果所有数字都用tostring转的话就超时。**

reverse函数不能用，会超时，手动for循环模拟reverse也会超时。

——————————

==**先自己找出来范围内所有符合要求的数，存在一个数组里，然后输出符合要求的数就行了，一次运算解决所有问题。**==

全局数组ans存储所有符合要求的数。

**Dealing函数：**

​	看一个数是不是符合题意。这里要先存一下原来的数字，因为每次操作数字都比原来少了一半。先在里面开辟一个辅助数组v，然后计算该数字的二进制位，把每一位都存到数组v里；

​	检测v数组里对称位置的两个数是不是一样的，如果不是直接返回；

​	tostring一下原来的数字（这里只用了一次所以可以），在str中也仿照对数组的处理方式，检测这个数的十进制形式是不是符合条件，不符合直接返回；

​	如果两次返回都没有被执行，就说明这个数符合条件，加到ans里；

​	根据输入的数字，输出ans里满足条件的数

注意，ans先用1000000调试一下看看最大的数是多少，再修改，就不用真的循环1000000次了。

```c++
#include<string>
#include<iostream>
#include<vector>
using namespace std;
 
vector<int> ans;
void Dealing(int x)
{
	vector<int> v;//记录x的二进制数的每一位
	int i = 0;
	if (x == 1) 
    {
		ans.push_back(1);
		return;
	}
	int x1 = x; //保留原始数据
    
	while (x)
    {    //记录二进制数的每一位
		v.push_back(x % 2);
		x /= 2;
		i++;
	}
	for (int j = 0; j < i / 2; j++) 
    { //不满足要求，退出
		if (v[j] != v[i - j - 1]) {
			return;
		}
	}
 
	string str = to_string(x1);
	int len = str.length();
	for (int i = 0; i < len / 2; i++)
    {  //十进制比对，这里tostring可以用，不会超时
		if (str[i] != str[len - i - 1])
			return;
		else continue;
	}
	ans.push_back(x1);//如果在上面那么多比对中都没退出，说明确实是回文数，ans加进去
}
int main()
{
	for (int i = 1; i <= 585585; i++) {//为什么是585585，调试看出来的，耍点诡计
		Dealing(i);
	}
	int n, m;
	while (cin >> n >> m) 
    {
		for (int i = 0; i < ans.size(); i++) 
        {
			if (ans[i] >= n && ans[i] <= m) {
				cout << ans[i] << endl;
			}
			if (ans[i] > m) {
				break;
			}
		}
		cout << endl;
	}
	return 0;
}
```

## B [1,n]中不含4，7的数

`不转为字符串，获取整数中的每一位`

关键代码：

```c++
int check(int x)
{
  while(x > 0)
  {
      if(x % 10 == 4 || x % 10 == 7 ){
          return 1;
      }
      x /= 10;
  }
  return 0;
}
```

全部代码：

```c++
#include<iostream>
#include<bits/stdc++.h>
using namespace std;

int check(int x)
{
  while(x > 0)
  {
      if(x % 10 == 4 || x % 10 == 7 ){
          return 1;
      }
      x /= 10;
  }
  return 0;
}
int main()
{
	int n,ans;
	while (cin >> n)
	{
      ans = n;
		for (int i = 1; i <= n; i++)
		{
			if(check(i) == 1){
             ans--;
            }
		}
		cout << ans << endl;
	}
	return 0;
}
```

## C 字符串去重问题

`双指针`

输入样例 1 

```c
12221133345678899
aabbccddeeffgg
```



输出样例 1

```c
1213456789
abcdefg
```

思路：
这个题有两种解法，一种是占用一个额外存储空间，另一种是就在原字符串上进行修改。

第一种：先把原字符串s的首位加进去，然后从s的第一位开始遍历s。如果s[i]表示的字符与ans的最后一位字符（表示方法：ans[ans.length()-1] )不相等，可以认为s中一段相同字符的序列已经结束了，那么把这个字符加进ans里，最后输出ans，注意格式！！

代码如下：

```c++
#include<iostream>
#include<bits/stdc++.h>
using namespace std;
 
int main()
{
	string s;
	while (cin >> s)
	{
		string ans = "";
		ans += s[0];
		for (int i = 1; i < s.length(); i++)
		{
			if (s[i] != ans[ans.length() - 1])
				ans += s[i];
		}
		cout << ans <<endl;
	}
	return 0;
}
```



第二种：双指针法，双指针似乎用while循环比较容易写

<img src="https://img-blog.csdnimg.cn/b6f446131c0041ec808f3e0cdc158bc2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6bmk5aSp5a-7,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img" style="zoom: 33%;" />

代码：

```c++
#include<iostream>
#include<bits/stdc++.h>
using namespace std;
 
int main()
{
	string s;
	while (cin >> s)
	{
		int fast = 1, slow = 0; //fast是跑的快的那个指针，slow是慢的
		while(fast < s.length())
		{
			if (s[slow] != s[fast]) //指的字符不一样
			{
				slow++; //slow向后挪一位
				s[slow] = s[fast]; //让fast指向的值覆盖slow指向的值
			}
			fast++;
		}
		cout << s.substr(0, slow + 1) << endl;
	}
	return 0;
}
```

## D 比较与固定数之差的绝对值

[1,6]

输入样例 1 

2 5
输出样例 1

3 0 3



输入样例 2 

2 4
输出样例 2

2 1 3

==思路：==

遍历1~6，然后比较每个数与输入的数的绝对值之间的大小，用三个变量来记录赢的情况和平局情况，由于这三个数相加一定是6，所以B赢的次数可以用6减去A赢的次数和平局次数。

```c
#include<iostream>
#include<bits/stdc++.h>
using namespace std;
 
int main()
{
	int a, b;
	while (cin >> a && cin >> b)
	{
		int awin = 0, bwin = 0, draw = 0;
		for (int i = 1; i <= 6; i++)
		{
			if (abs(a - i) < abs(b - i))
				awin++;
			else if (abs(a - i) == abs(b - i))
				draw++;
		}
		bwin = 6 - awin - draw;
		cout << awin << " " << draw << " " << bwin << endl;
	}
	return 0;
}
```

## E 车过拆墙

![img](https://img-blog.csdnimg.cn/img_convert/c290065f9cbcdfab0e9e8626caf7e3f2.png)

示例墙如图所示，车宽度是多少，就有多宽的墙全被拆除，问最少拆几块。



输入样例 1 

7 3
1 2 6 1 1 7 1
输出样例 1

3
**//注意这里有一个隐藏的换行符，注意输出格式！！**

解释：

在样本中，车宽是3，第三、第四、第五块砖的数量之和为8，是最少的，因此应将墙从第三位置移除。



==思路：==

<img src="C:\Users\Nanxi\AppData\Roaming\Typora\typora-user-images\image-20220609110525891.png" alt="image-20220609110525891"  />

```c++
#include<iostream>
#include<bits/stdc++.h>
using namespace std;
 
int main()
{
	int n, k;
	while (cin >> n && cin >> k)
	{
		//构造墙数组
		vector<int> v(n);
		for (int i = 0; i < n; i++)
			cin >> v[i];
 
		int fast = k - 1, slow = 0; //这是那个车的宽度（在数组中所以减1）
		int anspos = 0; //最后要输出的位置
		long mini = 30000; //拆除的最小砖块数，这个数小了会是WA
		long test = 0; //每次遍历所要拆的砖块数量，临时变量
 
 
		//先算第一次test
		for (int i = slow; i <= fast; i++)
			test += v[i];
 
		//这里注意是n - 1
		while (fast < n - 1)
		{
			//fast后移一位，test加上
			fast++;
			test += v[fast];
 
			//test减去最前面的值，加上后移一位的值
			test -= v[slow];
			slow++;	
 
			//判断，可能记录anspos
			if (mini > test)
			{
				mini = test;
				anspos = slow + 1;
			}
		}
		cout << anspos << endl;
	}
	return 0;
}
```

## F 某数的非空真子集

`组合数` `递归` `dfs 深搜 深度优先搜索`



<img src="C:\Users\Nanxi\AppData\Roaming\Typora\typora-user-images\image-20220609112604417.png" alt="image-20220609112604417" style="zoom:40%;" />



```c++
#include <bits/stdc++.h>
using namespace std;

int v[10];
int ans[1000]; 
int n, num; 

void dfs(int start, int cur)
{
	if (cur == num)
	{ 
		for (int i = 0; i < num; i++) 
			cout << ans[i];
		if(num != 0)
			cout << '\n';
		return;
	}
	for (int i = start; i < n; i++)
	{
		ans[cur] = v[i];
		dfs(i + 1, cur + 1);
	}
}

int main()
{
	while (cin >> n)
	{
		for (int i = 0; i < n; i++)
			cin >> v[i];
        
		for (num = 0; num < n; num++)
			dfs(0, 0);
        
		cout << endl;
	}

	return 0;
}
```

## G  简单排序

`排序`

有N个不同的数，每个数上有记录它们位置的标签（从1开始)。把闭区间[L，R]内的数进行升序排序，每次这样的操作后，第X个数是否仍在原来的位置。

**注意：**所有操作都是从初始位置独立地进行每一次排序。

提示

Explanation of first test case:

[1, 2, 3, 4, 5] — permutation after sorting, the 3-rd element is not changed, so answer is "Yes".
[3, 4, 5, 2, 1] — permutation after sorting, the 1-st element is changed, so answer is "No".
[5, 2, 3, 4, 1] — permutation after sorting, the 3-rd element is not changed, so answer is "Yes".
[5, 4, 3, 2, 1] — permutation after sorting, the 4-th element is not changed, so answer is "Yes".
[5, 1, 2, 3, 4] — permutation after sorting, the 3-rd element is changed, so answer is "No".

![image-20220609165118151](C:\Users\Nanxi\AppData\Roaming\Typora\typora-user-images\image-20220609165118151.png)

输入数据：

第一行输入两个空格分隔的整数N，M，代表序列长度和排序的次数。

第二行就是输入不同标签的数，标签无重复。

以下几行是执行排序的操作，看提示应该能懂

输入在文件（EOF）末尾终止。while(cin>>)连续输入的格式

输出

对于每一次排序，如果X位置的数没有改变，则打印“是”，否则打印“否”。

思路就是先记录下旧位置的数，然后把相应位置的数拿出一个单独数组里，排完之后再放回原数组对应位置，把新位置的数和进行比对。注意规范输出格式。

```c++
#include <bits/stdc++.h>
using namespace std;
 
void Ans(int sortnum, vector<int> v,int l, int r,int pos)
{
		int data = v[pos - 1];//先记录下来原始数据位置
		int lft = l - 1, rgt = r - 1;//换算成数组从0开始计数的习惯
		int sz = rgt - lft + 1;//辅助数组大小
		vector<int> help(sz);
		for (int i = 0; i < sz; i++)
			help[i] = v[lft++];
		sort(help.begin(), help.end());//排序
 
		int k = 0;
		int lv = l - 1;
 
		for (int i = 0; i < sz; i++)//把辅助数组的值更新到原数组到对应位置上去
			v[lv++] = help[k++];//i控制的是次数
 
		if (data == v[pos - 1])//比对
			cout << "Yes" << '\n';
		else
			cout << "No" << '\n';
 
}
int main() 
{
	int cakenum, sortnum;
	while (cin >> cakenum >> sortnum)
	{
		vector<int> v(cakenum);
		for (int i = 0; i < cakenum; i++)
			cin >> v[i];
        
		for (int i = 0; i < sortnum; i++)
		{
			int l, r, pos;
			cin >> l >> r >> pos;
            Ans(sortnum, v, l, r, pos);
		}
	}
	return 0;
}
```



## H 全排列

`全排列` `dfs 深搜 深度优先搜索`

不考虑“数字重复”的问题，因此不考虑“剪枝（去重）”

![image-20220609165726038](C:\Users\Nanxi\AppData\Roaming\Typora\typora-user-images\image-20220609165726038.png)

```c++
#include <iostream>
#include <string.h>
using namespace std;

bool visit[10];
int ans[10];
void dfs(int cur, int n)
{
    if (cur == n + 1)
    {
        for (int i = 1; i <= n; i++)
            printf("%d", ans[i]);
        printf("\n");
        return;
    }
    
    //如果是组合数，这里应该是i = start
    for (int i = 1; i <= n; i++) 
    {
        if (visit[i] == 0)
        {
            ans[cur] = i;
            //组合数就没有这个visit数组
            visit[i] = 1;
            dfs(cur + 1, n);
            visit[i] = 0;//回溯
        }
    }

}
int main()
{
    memset(visit, 0, sizeof(visit));
    int n;
    while (cin >> n)
    {
        dfs(1, n);
        printf("\n");
    }
   
    return 0;
}

```

## STL中的全排列

### std::next_permutation 正序全排列

![image-20220609174804720](C:\Users\Nanxi\AppData\Roaming\Typora\typora-user-images\image-20220609174804720.png)



### std::prev_permutation  倒序全排列

![image-20220609174659269](C:\Users\Nanxi\AppData\Roaming\Typora\typora-user-images\image-20220609174659269.png)

# 实验二 · 拓扑排序，dfs，回溯

## A dfs最大水坑问题

`dfs` `最大面积`

<img src="C:\Users\Nanxi\AppData\Roaming\Typora\typora-user-images\image-20220609172014111.png" alt="image-20220609172014111" style="zoom:50%;" />

Q：主函数里那个if判断能不写吗？

A：**如果说仅仅是为了避开o的位置**，**可以不写。**即使没有这一句，'o'的地方也会在dfs里被return掉；但是这个判断同时有着判断一个位置是不是a 以便初始化新岛屿大小的作用，所以不能不写。也就是说，主要还是为了找到新岛屿的位置，而不是为了优化o处的逻辑。



Q : 想问下是怎么实现“区域分离”的？我的代码中计算a的cnt都是连着算的，有几个a全算上了。

A : **主要在于主函数循环中那句cnt=0**。每次找到一个新岛屿，就在主函数里重新以大小为0的姿态进入dfs里寻找，同时，因为是上下左右的判断，如果周围是0的话就会一直return，直到退出。这样其他岛屿来搜索的时候，如果遇到之前的位置，那么不是flag标记了就是o退出了，起到一个隔绝的作用。



Q：你这cnt怎么只有++没有--啊？说好的回溯呢？

A：因为--的情况放到了return里，如果不是a就直接退出了。只有是a的时候才++，而不是上来不分青红皂白就先++，如果是一进函数就++，那的确需要在return之前--，保证**只有遇到a才++。**

```c++
#include<iostream>
#include<vector>
using namespace std;

int cnt = 0;
int dx[4] = { 0, 0, 1, -1 };
int dy[4] = { 1, -1, 0, 0 };
void dfs(vector<vector<char>>& v, vector<vector<bool>>& flag, int x, int y, int n)
{
    //能进且没走过
	if (x >= 0 && x < n && y >= 0 && y < n && !flag[x][y])
	{
		if (v[x][y] == 'o') {
			return;
		}
		//注意，这里只标记了水坑区域，没有标记陆地区域
		flag[x][y] = true;
		cnt++;

		for (int i = 0; i < 4; i++)
			dfs(v, flag, x + dx[i], y + dy[i], n);
	}
}
int main()
{
	int n;
	while (cin >> n && n != 0)
	{
        //输入地图
		vector<vector<char>> v(n, vector<char>(n, 'o'));
		for (int i = 0; i < n; i++)
			for (int j = 0; j < n; j++)
				cin >> v[i][j];

        //flag就是visit数组
		int ans = 0;
		vector<vector<bool>> flag(n, vector<bool>(n, false));
        
		for (int i = 0; i < n; i++)
		{
			for (int j = 0; j < n; j++)
			{
				if (v[i][j] == 'a')
				{
					cnt = 0;
					dfs(v, flag, i, j, n);
					ans = max(ans, cnt);
				}
			}
		}
        
		cout << ans << endl;
		cnt = 0;
	}
	return 0;
}
```

### 变式：从指定位置出发能遍历的最多块数 （D）

``` c++
#include<iostream>
#include<vector>
using namespace std;

int cnt = 0;
bool gflag = 0;
int dx[4] = { 0, 0, 1, -1 };
int dy[4] = { 1, -1, 0, 0 };
void dfs(vector<vector<char>>& v, vector<vector<bool>>& flag, int x, int y, int n, int m)
{
	if (x >= 0 && x < m && y >= 0 && y < n && !flag[x][y])
	{
		if (v[x][y] == 'R')
			return;

		if (v[x][y] == 'G')
			gflag = 1;

		flag[x][y] = true;
		cnt++;

		for (int i = 0; i < 4; i++)
			dfs(v, flag, x + dx[i], y + dy[i], n, m);
	}
}
int main()
{
	int n, m;
	while (scanf("%d %d", &n, &m) != EOF && n != 0 && m != 0)
	{
		vector<vector<char>> v(m, vector<char>(n));
		for (int i = 0; i < m; i++)
			for (int j = 0; j < n; j++)
				cin >> v[i][j];

		int ans = 0;
		vector<vector<bool>> flag(m, vector<bool>(n, false));
		for (int i = 0; i < m; i++)
		{
			for (int j = 0; j < n; j++)
			{
				if (v[i][j] == 'D' || v[i][j]=='G')//这里把起点也要算上
				{
					cnt = 0;
					dfs(v, flag, i, j, n, m);

					if (gflag)
					{
						ans = cnt;
						printf("%d", ans);
						gflag = 0;
					}
				}
			}
		}
		printf("\n");

	}
	return 0;
}
```



## B 拓扑排序 · 模板题

`拓扑排序`

输入示例解析：4队排在3队前，1队排在2队前，以此类推，求出最终的排序。

![image-20220609173149780](C:\Users\Nanxi\AppData\Roaming\Typora\typora-user-images\image-20220609173149780.png)

1.读入图结构，记录每个节点的入度数（也就是 有多少条边的终点为该节点）。
2.每次寻找入度为0的点，push_back到ans，然后寻找到的节点的入度减1（入度为-1则后续不会再被考虑），然后将该点连接的点的入度减1。这一步的目的可以理解为将入度为0的点从图中移除，将问题变为求剩下的结点的拓扑排序。
3.循环第二步直到所有结点均已进入ans

```c++
#include<iostream>
#include <list>
#include<vector>
#include <queue>
using namespace std;

void topo(vector<int>& indegree, list<int>* adj, int n)
{
    vector<bool>visit(n, false);
    queue<int> q;
    
    int cnt = 0;
    while (cnt < n)
    {
        for (int i = 0; i < n; i++)
        {
            //每次寻找入度为0的点，push_back到ans
            if (indegree[i] == 0 && visit[i] == false)
            {
                q.push(i + 1);
                visit[i] = true;
                
                list<int>::iterator it = adj[i].begin();
                while (it != adj[i].end())
                {
                    indegree[*it]--;
                    it++;
                }
                break;
            }
        }
        cnt++;
    }
    
    //输出结果
    while (!q.empty())
    {
        cout << q.front();
        q.pop();
        if (!q.empty())
            cout << " ";
    }

}
int main()
{
    int n, m;
    while (cin >> n >> m)
    {
        list<int>* adj = new list<int>[n];
        
        vector<int> indegree(n);
        for (int i = 0; i < n; i++)
            indegree[i] = 0;

        //记录每个节点的入度数
        //从p1到p2的单向连通
        for (int i = 0; i < m; i++)
        {
            int p1, p2;
            cin >> p1 >> p2;
            adj[p1 - 1].push_back(p2 - 1);
            indegree[p2 - 1]++;
        }
        topo(indegree, adj, n);
        printf("\n");
    }

    return 0;
}
```

### 法二：

```c++
#include <bits/stdc++.h>
using namespace std;

const int maxn = 505;
int G[maxn][maxn];
int indegree[maxn];
int n,m,u,v;

int main(int argc, char const *argv[])
{
	while(cin >> n >> m && n != 0)
	{
		memset(indegree,0,sizeof(indegree));
		memset(G,0,sizeof(G));
		
		for(int i = 0;i < m; i++)
		{
			cin >> u >> v;
			G[u][v] = 1;
			indegree[v]++;
		}
		
		vector<int> ans;
		while(ans.size() != n)
		{
			for(int i = 1;i <= n; i++)
			{
				if(indegree[i] == 0)           
				{
					indegree[i]--;              // 将入度变为-1就不再有机会被加入ans 
					ans.push_back(i);
					for(int j = 1;j <= n; j++)   //将i连接的点的入度都减1 
						if(G[i][j])
							indegree[j]--;
				}
			}	
		}
		for(int i = 0;i < ans.size(); i++)
			cout << ans[i] << " ";
		cout << endl;
	}
	return 0;
}
```



## C n皇后问题

`回溯`

```c++
#include<string>
#include<iostream>
#include<vector>
using namespace std;

vector<vector<string>> result;
bool isValid(int row, int col, vector<string>& chessboard, int n)
{
    int count = 0;
    // 检查列
    for (int i = 0; i < row; i++) { 
        if (chessboard[i][col] == 'Q') {
            return false;
        }
    }
    // 检查 45度角是否有皇后
    for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {
        if (chessboard[i][j] == 'Q') {
            return false;
        }
    }
    // 检查 135度角是否有皇后
    for (int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {
        if (chessboard[i][j] == 'Q') {
            return false;
        }
    }
    return true;
}
// n 为输入的棋盘大小
// row 是当前递归到棋盘的第几行了
void backtracking(int n, int row, vector<string>& chessboard) {
    if (row == n) {
        result.push_back(chessboard);
        return;
    }
    for (int col = 0; col < n; col++) {
        if (isValid(row, col, chessboard, n)) { // 验证合法就可以放
            chessboard[row][col] = 'Q'; // 放置皇后
            backtracking(n, row + 1, chessboard);
            chessboard[row][col] = '.'; // 回溯，撤销皇后
        }
    }
}
int main()
{
	int n;
    while(cin >> n)
    {
      result.clear();
      vector<string> chessboard(n, string(n, '.'));
      backtracking(n, 0, chessboard);
      cout << result.size()<<endl;    
    }

	return 0;
}
```



## E 最短路问题

 看PDF-实验2---Kanto

# 实验3 二分，递归，分治

## A 二分，<=

`二分查找`

给定长度为 n 的非降序序列a，m次询问，每次询问给定一个数x，输出序列 a 中第一个小于等于 x 的数。

### zsj

```c++
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring> 
using namespace std;
 
const int N = 100007;
 
int a[N];
 
 
int main(){
	int n, m;
	while (scanf("%d%d", &n, &m) != EOF){
		for (int i = 1; i <= n; i++){
			scanf("%d", &a[i]);
		}
		sort(a + 1, a + 1 + n);
		while (m--){
			int x;
			scanf("%d", &x);
			int l = 1, r = n;
			while (l < r){
				int mid = (l + r + 1) >> 1;
				if (a[mid] <= x){
					l = mid;
				}else{
					r = mid - 1;
				}
			}
			printf("%d", a[l]);
			if (m){
				printf(" ");
			}
		}
		printf("\n");
	}
	return 0;
}

```

### mine

```c++
#include<bits/stdc++.h>
#include<stdio.h>
using namespace std;
long long v[100000];
int BSearch(int left, int right, int value)
{
	int middle;
	while (left <= right)
	{
		middle = left + (right - left) / 2;
		if (v[middle] > value)
			right = middle - 1;
		else if (v[middle] < value)
			left = middle + 1;
		else
			return v[middle];
	}
	return v[middle] > value?v[middle - 1]:v[middle];
}
int main()
{
	long n, m;
	while (scanf("%d %d", &n, &m) != EOF) 
	{
		for (int i = 0; i < n; i++)
			scanf("%d", &v[i]);

		for (int i = 0; i < m; i++)
		{
			int round;
			cin >> round;
			if(i!=m-1)
			{
				if(v[0]>round)
				{
					cout<<v[0]<<" ";
					continue;
				}
				else{
					printf("%d ", BSearch(0,n-1,round));
				}				
			}
			else
			{
				if (v[0] > round)
					cout << v[0] << endl;
				else{
					cout << BSearch(0, n-1, round) << endl;
				}
			}
		}
	}
	return 0;
}
```

## B 动规

`动态规划`

给定长度为 n 的序列 a，求连续子序列之和的最大值。

```c++
#include<bits/stdc++.h>
#include<stdio.h>
using namespace std;

int main()
{
	int n;
	scanf("%d", &n);
	for (int i = 0; i < n; i++)
	{
		int m;
		scanf("%d", &m);
		vector<long long> v(m);
		vector<long long>dp(m);
		for (int j = 0; j < m; j++)
			cin >> v[j];

		dp[0] = v[0];
		long long res = dp[0];
		for (int j = 1; j < m; j++)
		{
			dp[j] = max(dp[j - 1] + v[j],v[j]);
			if (res < dp[j])
				res = dp[j];
		}
		printf("%ld",res);
        if(i!=n-1)
          printf("\n");
	}
	return 0;
}
```

## C 求序列中位数

`二分`

给定长度为 n 的序列 a ，输出序列 a 的中位数，要求时间复杂度为 O ( n )。

```c++
#include<iostream>
using namespace std;
int arr[2000000];

void quick_select(int arr[], int k, int start, int end)
{
    if(start > end)
        return;
    
    int left = start;
    int right = end;
    int pivot = arr[start];
    while(1)
	{
        while(arr[right] >= pivot && left<right)
			right--;
        while(arr[left] <= pivot && left<right)
			left++;
        if(left<right)
            swap(arr[left], arr[right]);
        else
            break;
    }
	swap(arr[left], arr[start]);
    if(k<=left)
        quick_select(arr, k, start, left-1);
    else
        quick_select(arr, k, left+1, end);
}
int main()
{
	int n;
	scanf("%d",&n);
	for(int i=0;i<n;i++)
	{
		int m;
		scanf("%d",&m);
		for(int i=0;i<m;i++)
			scanf("%d",&arr[i]);

	    quick_select(arr, (m+1)/2, 0, m-1);
	    printf("%d", arr[m/2]);
	    if(i!=n-1)
	    	printf("\n");
	}
    return 0;
}
```

## D 分治

`分治`

平面直角坐标系XOY中，给定几个点，第i个点的坐标为(xi,yi),求距离最近两个点的距离。

### zsj

```c++
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <cmath>
using namespace std;
 
const int N = 100007;
const int inf = 0x3f3f3f3f;
 
struct node{
	double x, y;
}p[N], pp[N];
 
 
bool cmpx(node a, node b){
	if (a.x == b.x){
		return a.y < b.y;
	}
	return a.x < b.x;
}
 
bool cmpy(node a, node b){
	return a.y < b.y;
}
 
double calcDis(node a, node b){
	double ans = sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));
	return ans;
}
 
double solve(int l, int r){
	if (l == r){
		return inf;
	}
	if (r - l == 1){
		return calcDis(p[l], p[r]);
	}
	if (r - l == 2){
		return min(calcDis(p[l], p[l + 1]), min(calcDis(p[l + 1], p[r]), calcDis(p[l], p[r])));
	}
	int mid = (l + r) >> 1;
	double ans = min(solve(l, mid), solve(mid + 1, r));
	int cnt = 0;
	for (int i = l; i <= r; i++){
		if (fabs(p[i].x - p[mid].x) <= ans){
			pp[++cnt] = p[i];
		}
	}
	sort(pp + 1, pp + 1 + cnt, cmpy);
	for (int i = 1; i <= cnt; i++){
		for (int j = i + 1; j <= cnt; j++){
			if (pp[j].y - pp[i].y > ans){
				break;
			}
			ans = min(ans, calcDis(pp[i], pp[j]));
		}
	}
	return ans;
}


int main(){
	int n;
	while (scanf("%d", &n) != EOF){
		for (int i = 1; i <= n; i++){
			scanf("%lf%lf", &p[i].x, &p[i].y);
		}
		sort(p + 1, p + 1 + n, cmpx);
		int ans = solve(1, n);
		printf("%d\n", ans);
	}
	return 0;
}

```

### mine

```c++
#include<bits/stdc++.h>
using namespace std;

#define MAXLEN 1000000


typedef struct Point
{
    float x, y;
};

float Distance(Point a, Point b)
{
    return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));
}

bool cmp(Point a, Point b)
{
    return a.x < b.x;
}
void get(Point points[], int len, Point pts1[],Point pts2[])
{
    for (int i = 0; i < len / 2; i++)
        pts1[i]=(points[i]);
    for (int i = len / 2,j=0; i < len; i++)
        pts2[j++]=(points[i]);
}
int set3(Point pts3[], Point points[], int length, float mid, float distance)
{
	int k=0;
    for (int i = 0; i < length; i++)
        if (abs(points[i].x - mid) <= distance)
            pts3[k++]=(points[i]);
    return k;
}

void SetPoints(vector<Point>& points, int length)
{
    srand(unsigned(time(NULL))); 
    for (int i = 0; i < length; i++)
    {
        points[i].x = (rand() % 20000) / 100.0 - 100;   
        points[i].y = (rand() % 20000) / 100.0 - 100;
    }

}

float Closest(Point points[], int length, Point& a, Point& b)
{
    if (length < 2)
        return MAXLEN;
    if (length == 2)
    {
        a = points[0];
        b = points[1];
        return Distance(points[0], points[1]);
    }

    else
    {
        Point a1, b1, a2, b2;
        sort(points, points+length, cmp);
        Point* pts1 = new Point[length];    
        Point* pts2 = new Point[length];
        get(points, length, pts1, pts2);

        float d1, d2;
        d1 = Closest(pts1, length / 2, a1, b1);
        d2 = Closest(pts2, length - length / 2, a2, b2);

        float distance = min(d1, d2);
        if (d1 < d2)
        {
            a = a1;
            b = b1;
        }
        else
        {
            a = a2;
            b = b2;
        }
        float mid = points[(length - 1) / 2].x;

        Point* pts3 = new Point[length];
        int len = set3(pts3, points, length, mid, distance);
	
        for (int i = 0; i < len; i++)
            for (int j = i + 1; j <= 7 + i && j < len; j++)
            {
                int d = distance;
                distance = min(distance, Distance(pts3[i], pts3[j]));
                if (Distance(pts3[i], pts3[j]) < distance)
                {
                    a = pts3[i];
                    b = pts3[j];
                }
            }

        return distance;
    }

}

int main()
{
    int n;
    Point a, b;

    while (scanf("%d", &n) != EOF)
    {
        Point* points = new Point[n];
        for (int i = 0; i < n; i++)
            cin >> points[i].x >> points[i].y;
        cout << (int)Closest(points, n, a, b) << endl;
    }
    return 0;
}
```



## E 二分

这个看PDF的吧。。

## F 二分

PDF吧，不太会

```c++
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring> 
using namespace std;
 
typedef long long ll;
const int N = 100007;
const ll INF = 0x3f3f3f3f3f3f3f3f;
 
ll a[N];
int n, k;
 
bool check(ll x){
	int cnt = 0, idx = 0;
	while (idx < n){
		cnt++;
		int pos = upper_bound(a, a + 1 + n, a[pos] + x) - a;
		if (a[pos] > a[idx] + x){
			pos--;
		}
		if (pos == idx){
			return 0;
		}
		idx = pos;
	}
	if (cnt > k){
		return 0;
	}
	return 1;
}


int main(){
	while (scanf("%d%d", &n, &k) != EOF){
		for (int i = 1; i <= n; i++){
			scanf("%lld", &a[i]);
		}
		ll l = 1, r = INF;
		while (l < r){
			ll mid = (l + r) >> 1;
			if (check(mid)){
				r = mid;
			}else{
				l = mid + 1;
			}
		}
		printf("%lld\n", l);
	}
	return 0;
}

```

# 实验4  动态规划

## A 斐波那契数列/跳台阶

```c++
#include<iostream>
#include<cstdlib>
#include<bits/stdc++.h>
using namespace std;

int dp[1000001];
int MOD = (int)1e9 + 7;
void Init()
{
    dp[1] = 1;
    dp[2] = 1;
    for (int i = 3; i < 1000001; i++) {
        dp[i] = (dp[i - 1] % MOD + dp[i - 2] % MOD) % MOD;
    }
}
int main()
{
    int n;
    Init();
    scanf_s("%d", &n);
    for (int i = 0; i < n; i++)
    {
        int m;
        scanf_s("%d", &m);
        long x = dp[m];
        cout << x << endl;
    }
    return 0;
}
```

## B

```c++
#include<iostream>
#include<vector>
#include<stdio.h>
#include<math.h>
using namespace std;

int main()
{
	int n;
	cin >> n;
	while (n--)
	{
		//含义：[i][j]是到该点的最大值
		vector<vector<int>> dp(50, vector<int>(50, 0));
		vector<vector<int>> map(50, vector<int>(50, 0));
		int row;
		scanf_s("%d", &row);
		for (int i = 0; i < row; i++)
			for (int j = 0; j <= i; j++)
				cin >> map[i][j];
		//3.初始化
		for (int i = 0; i < row; i++)
		{
			dp[i][0] = map[i][0];
			dp[i][i] = map[i][i];
		}
		dp[0][0] = map[0][0];
		dp[1][0] = map[0][0] + map[1][0];
		dp[1][1] = map[0][0] + map[1][1];

		if (row == 3) 
			return max(dp[1][0], dp[1][1]);
		
		int maxi = max(dp[1][0], dp[1][1]);
		for (int i = 2; i < row; i++)
		{
			for (int j = 0; j <= i + 1; j++)
			{
				if (j == 0)
					dp[i][j] = dp[i - 1][0] + map[i][0];//最左
				else if (j == i + 1)
					dp[i][j] == dp[i - 1][i - 1] + map[i][j];//最右
				else
					dp[i][j] = max(dp[i - 1][j - 1] + map[i][j], dp[i - 1][j] + map[i][j]);

				if (i == row - 1)
					maxi = max(dp[row - 1][j], maxi);
			}
		}
		
		cout << maxi << endl;
	}
	return 0;
}
```

## C 完全背包

```c++
#include<iostream>
#include<vector>
#include<stdio.h>
#include<math.h>
using namespace std;

int main()
{
	int t;
	cin >> t;
	while (t--)
	{
		int n, w;
		cin >> n >> w;
		vector<int> value(n, 0);
		vector<int> weight(n, 0);
		for (int i = 0; i < n; i++)
			cin >> value[i];
		for (int i = 0; i < n; i++)
			cin >> weight[i];
		//载重能力是i的时候所获得的最大价值是dp[i]
		vector<int> dp(w + 1, 0);
		//int maxi = INT_MIN;
		for (int i = 1; i < weight.size(); i++)
		{
			for (int j = weight[i]; j <= w; j++)
			{
				dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
				//maxi = max(maxi, dp[j]);
			}
		}
		cout << dp[w] << endl;
	}
	return 0;
}
```

## D 浮点数01背包

```c++
#include <stdio.h>
#include <string.h>
#include <iostream>
#include<bits/stdc++.h>
using namespace std;

int main()
{
    int T;
    cin >> T;
    while (T--)
    {
        int n;
        double m;
        cin >> m >> n;

        int sum = 0;
        vector<int> value(10005, 0);
        vector<double> weight(10005, 0), dp(10005, 0);
        //dp数组定义：在value=i时不爆炸的最大概率
        dp[0] = 1.0;
        for (int i = 0; i < n; i++)
        {
            cin >> value[i] >> weight[i];
            sum += value[i];
        }

        int maxi = 0;
        for (int i = 0; i < n; i++)//物品
        {
            for (int j = sum; j >= value[i]; j--)//背包容量
            {
                dp[j] = max(dp[j], dp[j - value[i]] * (1 - weight[i]));
                if (dp[j] >= 1 - m){
                    maxi = max(j, maxi);
                }
            }
        }


        cout << maxi << endl;
    }
    return 0;
}
```



## E 最大上升子序列之和

```c++
#include <iostream>
#include <vector>
using namespace std;

int num[1005];
int dp[1005];
void doit(int n)
{
	dp[0] = num[0];
	int maxi = num[0];
	for (int i = 1; i < n; i++)
	{
		for (int j = 0; j < i; j++)
		{
			if (num[j] < num[i] && dp[j] + num[i] > dp[i])
				dp[i] = dp[j] + num[i];
			else if (dp[i] < num[i])
				dp[i] = num[i];
		}
		if (dp[i] > maxi)
			maxi = dp[i];
	}
	cout << maxi << endl;
}
int main()
{
	int n;
	while (cin >> n) 
	{
		for (int i = 0; i < 1005; i++)
		{
			num[i] = 0;
			dp[i] = 0;
		}
		for (int i = 0; i < n; i++)
			cin >> num[i];
		doit(n);
		for (int i = 0; i < 1005; i++)
		{
			num[i] = 0;
			dp[i] = 0;
		}
	}
	return 0;
}

```



## F 完全背包

```c++
#include <iostream>
#include <vector>
using namespace std;

int price[1000];
int length[1000];

void dp(int n)
{
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= i; j++)
			price[i] = max(price[i], length[j] + price[i - j]);
	cout << price[n] << endl;
}

int main()
{
	int n;
	while (cin >> n) 
	{
		for (int i = 1; i <= n; i++)
			cin >> length[i];
		dp(n);
        for (int i = 0; i < 1000; i++)
        {
            price[i] = 0;
            length[i] = 0;
        }
	}
	return 0;
}
```

```c++
//王浩宇
#include <iostream>
#include <vector>
using namespace std;

int max(int a, int b)
{
	if (a > b)
		return a;
	return b;
}

int dp(vector<int> money, vector<int> list)
{
	int temp = 0;
	for (int i = 1; i < money.size(); i++)//-1
		for (int j = 1; j <= i; j++)
			money[i] = max(money[i], list[j] + money[i - j]);

	return money[money.size() - 1];
}

int main()
{
	int n;
	while (cin >> n) {

		vector<int> money(n + 1, 0);
		vector<int> list(n + 1, 0);
		for (int i = 1; i <= n; i++)
			cin >> list[i];

		cout << dp(money, list)<<endl;
		money.clear();
		list.clear();
	}
	return 0;
}
```

# 实验五 贪心

哈夫曼树，硬币问题，最小生成树，迪杰斯特拉

## A 硬币问题

![image-20220610204539782](C:\Users\Nanxi\AppData\Roaming\Typora\typora-user-images\image-20220610204539782.png)

```c++
#include <stdio.h>
#include <string.h>
#include <iostream>
#include<bits/stdc++.h>
using namespace std; 
vector<int> coins = { 1, 2, 5, 10, 20, 50, 100 };
int main()
{
    int T;
    cin >> T;
    while (T--)
    {
        int n;
        cin >> n;
        int num = 0;
        int len = coins.size() - 1;
        while (n && len>=0)
        {
            if (coins[len] <= n) {
                n -= coins[len];
                num++;
            }
            else {
                len--;
            }
        }
        cout << num << endl;
    }
    return 0;
}
```

## B 哈夫曼编码

![image-20220610204639625](C:\Users\Nanxi\AppData\Roaming\Typora\typora-user-images\image-20220610204639625.png)

```c++
#include<bits/stdc++.h>
using namespace std;

class cmp
{
public:
	bool operator() (int& a, int& b) {
		return a < b;
	}
};


int main()
{
	int n;
	cin >> n;
	while (n--)
	{
		int w;
		string s;
		cin >> w >> s;
		vector<int> v(128, 0);
		priority_queue<int, vector<int>, greater<int> > q;
		for (int i = 0; i < s.length(); i++){
			v[s[i]]++;
		}
		for (int i = 0; i < 128; i++)
		{
			if (v[i] != 0){
				q.push(v[i]);
			}
		}
		if (q.size() == 1){
			return !(q.top() > w);
		}

		while (!q.empty())
		{
			if (q.size() == 1){
				break;
			}
			int a = q.top();
			q.pop();
			int b = q.top();
			q.pop();
			w -= (a + b);
			if (w < 0) {
				cout << "no" << endl;
				break;
			}
			q.push(a + b);

		}
		if(w >= 0)
			cout << "yes" << endl;

		v.clear();
		
	}
	return 0;
}

```



## C 贪心

![image-20220610204844093](C:\Users\Nanxi\AppData\Roaming\Typora\typora-user-images\image-20220610204844093.png)

```c++
#include<bits/stdc++.h>
using namespace std;
 
typedef struct enemy
{
	int hp, dps;
	double res;
};
class cmp
{
public:
	bool operator() (enemy& a, enemy& b) {
		return a.res < b.res;
	}
};
int main()
{
	int n;
	while (cin >> n && n != EOF)
	{
		int sum = 0;
		int pre = 0;
		priority_queue<enemy, vector<enemy>, cmp > q;
		for (int i = 0; i < n; i++)
		{
			enemy temp;
			cin >> temp.dps >> temp.hp;
			temp.res = (double)temp.dps / temp.hp;
			q.push(temp);
		}
		while (!q.empty())
		{
			enemy temp = q.top();
			q.pop();
			sum = sum + temp.dps * (temp.hp + pre);
			pre += temp.hp;
		}
		cout << sum << endl;
	}
	return 0;
}
```



## D 引爆气球



```c++
#include<bits/stdc++.h>
using namespace std;

typedef struct interval
{
	int begin, end;
};

bool cmp (interval& a, interval& b) {
	return a.begin < b.begin;
}
int main()
{
	int n;
	while (cin >> n && n != EOF)
	{
		int sum = n;
		int res = 1;
		vector<interval> v(n);
		for (int i = 0; i < n; i++)
			cin >> v[i].begin >> v[i].end;

		sort(v.begin(), v.end(), cmp);
		
		for (int i = 1; i < v.size(); i++)
		{
			if (v[i].begin >= v[i - 1].end) {//不挨着
				res++;
			}
			else{//挨着，更新最小右边界
				v[i].end = min(v[i - 1].end, v[i].end);
				sum--;
			}
		}
		//cout <<"res="<< res << " " <<"sum="<< sum << endl;
		cout << res << endl;
	}
	return 0;
}

```



## E kruskal

克鲁斯卡尔算法查找最小生成树的方法是：将连通网中所有的边按照权值大小做升序排序，从权值最小的边开始选择，只要此边不和已选择的边一起构成环路，就可以选择它组成最小生成树。对于 N 个顶点的连通网，挑选出 N-1 条符合条件的边，这些边组成的生成树就是最小生成树。

张宇航

```c++
#include <iostream>
#include<algorithm>
#include<string>
#include<map>
#include<queue>
#include<vector>
using namespace std;
const int N = 1005;
struct node 
{
	int x1;
	int x2;
	int weight;
};
node a[N];
int per[N];//前驱结点
bool cmp(node a, node b)
{return a.weight < b.weight;}
int find(int x)
{
	if (x == per[x])
		return x;
	return per[x] = find(per[x]);
}

int main()
{
	int n, m;
	while (cin >> n >> m)
	{
		int sum = 0;//记录最小花费
		int ans = 0;//记录生成树的个数
		for (int i = 0; i < n; i++)
			cin >> a[i].x1 >> a[i].x2 >> a[i].weight;
			
		for (int i = 1; i <= m; i++)
			per[i] = i;
			
		int num = m - 1;
		if (n < num)//边不够
		{
			cout << "-1" << endl;
			continue;
		}
		
		sort(a, a + n, cmp);
		for (int i = 0; i < n; i++)
		{
			//合并
			int xx = find(a[i].x1);
			int yy = find(a[i].x2);
			if (xx != yy)
			{
				per[xx] = yy;
				sum += a[i].weight;
			}

		}
		for (int i = 1; i <= m; i++)
			if (i == per[i])
				ans++;//只有一个根结点

		if (ans == 1)//只有一棵生成树
			cout << sum << endl;
		else
			cout << "-1" << endl;
	}
	return 0;
}
```

我的

```c++
#include<bits/stdc++.h>
using namespace std;

struct edge 
{
    int initial;
    int end;
    int weight;
};

//边按照权值大小升序排序
int cmp(edge& a, edge& b) {
    return a.weight < b.weight;
}

void kruskal(vector<edge> edges, int n, int m)
{
    vector<int> assists(m + 1);
    int num = 0;
    //初始状态下，每个顶点的标记都不相同
    for (int i = 1; i <= m; i++) {
        assists[i] = i;
    }
    //根据权值对所有边进行升序排序
    sort(edges.begin(), edges.end(), cmp);

    int sum = 0;
    //遍历所有的边
    for (int i = 0; i < n; i++)
    {
        //找到当前边的两个顶点在 assists 数组中的位置下标
        int initial = edges[i].initial;
        int end = edges[i].end;
        //如果顶点位置存在且顶点的标记不同，说明不在一个集合中，不会产生回路
        if (assists[initial] != assists[end])
        {
            //计数+1
            num++;
            sum += edges[i].weight;
            int ele = assists[end];
            //将新加入生成树的顶点标记全部改为一样的
            for (int k = 1; k <= m; k++)
            {
                if (assists[k] == ele) {
                    assists[k] = assists[initial];
                }
            }
            //如果选择的边的数量和顶点数相差1，证明最小生成树已经形成，退出循环
            if (num == m - 1)
                break;
        }
    }
    int ans=0;
	for (int i = 1; i <= m; i++)
	{
		if (i == assists[i])
			ans++;//只有一个根结点
	}
	if (ans == 1)//只有一棵生成树
		cout << sum << endl;
	else
		cout << "-1" << endl;
}
int main()
{
    int n, m;
    while (scanf("%d %d", &n, &m) != EOF)
    {
        set<int> s;
        vector<edge> edges(n);
        for (int i = 0; i < n; i++)
        {
            scanf("%d %d %d", &edges[i].initial, &edges[i].end, &edges[i].weight);
            s.insert(edges[i].initial);
            s.insert(edges[i].end);
        }
		if (n < m - 1)
		{
			cout << "-1" << endl;
			continue;
		}
        int flag = 0;
        for (int i = 1; i <= m; i++)
        {
            if (s.find(i) == s.end()) {
                cout << -1 << endl;
                flag = 1;
                break;
            }
        }
        if (flag) {
            continue;
        }
        kruskal(edges, n, m);
    }
    return 0;
}
```

## F prim 普利姆算法模板题

普里姆算法查找最小生成树的过程，采用了贪心算法的思想。对于包含 N 个顶点的连通网，普里姆算法每次从连通网中找出一个权值最小的边，这样的操作重复 N-1 次，由 N-1 条权值最小的边组成的生成树就是最小生成树。

王浩宇

```c++
#include <iostream>
#include<algorithm>
#include<string>
#include<map>
#include<queue>
#include<vector>
using namespace std;
struct node
{
    int next;
    int w;
};
node p, q;
vector<node>g[1001];//存储每个点可以直接到达的点以及路径长度
bool visit[1001] = { false };//标记是否访问过这个点
int d[1001] = { 0x3f3f3f3f };//记录起点到终点的最短距离
int pre[1001];//记录最短路径上结点的前一个结点

void dij(int s,int n)
{
    for (int i = 0; i < 1001; i++)
        visit[i] = false;
    
    for (int i = 0; i < 1001; i++)
        d[i] = 0x3f3f3f3f;

    for (int i = 1; i <= n; i++)
        pre[i] = i;
    d[s] = 0;
    for (int i = 1; i <= n; i++)
    {
        int Min = 0x3f3f3f3f;
        int k = -1;
        for (int j = 1; j <= n; j++)
        {
            if (visit[j] == false && d[j] < Min)
            {
                k = j;
                Min = d[j];
            }
        }
        if (k == -1)
            return;
        visit[k] = true;
        for (int j = 0; j < g[k].size(); j++)
        {
            int h = g[k][j].next;
            if (visit[h] == false && (d[k] + g[k][j].w < d[h] || (d[k] + g[k][j].w == d[h] && k < pre[h])))
            {
                d[h] = d[k] + g[k][j].w;
                pre[h] = k; 
            }
        }
    }
}
int main()
{
    int n, m, start, end;
    while (cin>>n>>m>>start>>end)
    {
        for (int i = 0; i < 1001; i++)
            g[i].clear();
        while(m--)
        {
            int x, y, weight;
            cin >> x >> y >> weight;
            p.next = y;
            p.w = weight;
            q.next = x;
            q.w = weight;
            g[x].push_back(p);
            g[y].push_back(q);
        }
        dij(start,n);
        if (d[end] != 0x3f3f3f3f)
        {
            cout << d[end] << endl;
        }
        else
            cout << "-1" << endl;
    }
    return 0;
}
```

默认给不存在的边初始化成10000太小了，0x3f3f3f3f

考虑输入重复边的情况，需要保证matrix里存的是边的最小长度，重复的话存之前需要min判断一下

```c++
#include<bits/stdc++.h>
using namespace std;


void Find(int n, int m, int from, int to)
{
	//int matrix[1005][1005];vs2019会崩溃，用vector动态数组就不会了
	vector<vector<int>> matrix(1005, vector<int>(1005, 0));
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= n; j++)
			matrix[i][j] = 0x3f3f3f3f;

	int h, k, len;
	for (int i = 1; i <= m; i++)
	{
		cin >> h >> k >> len;
		matrix[h][k] = min(matrix[h][k], len);
		matrix[k][h] = min(matrix[k][h], len);
	}
	vector<int> visit(1002, 0);
	vector<int> path(1002, 0x3f3f3f3f);
	
	//初始化
	for (int i = 1; i <= n; i++)
	{
		path[i] = matrix[from][i];
		visit[i] = 0;
	}
	path[from] = 0;
	visit[from] = 1;

	//n个顶点，因此共比较 n-1 次 
	for (int j = 1; j < n; j++)
	{
		int min = 0x3f3f3f3f, nextvex = -1;
		for (int i = 1; i <= n; i++)
		{
			//没有访问过该点  且  初始点到该点的距离小于当前的最小值
			if (!visit[i] && path[i] < min)
			{
				min = path[i];//min就是当前的路径
				nextvex = i;//下一个据点就是这个点了
			}
		}
		if (nextvex == -1) {
			break;
		}
		visit[nextvex] = 1;//只有最终确定好了据点，才真正去visit它

		//通过据点，更新初始点到所有点的距离
		for (int i = 1; i <= n; i++)
		{	   //该点没有被访问过，且 初始点到该点的距离 比 初始点与据点之间的距离 与 据点到该点的距离 大
			if (!visit[i] && path[i] > path[nextvex] + matrix[nextvex][i] && matrix[nextvex][i] < 0x3f3f3f3f)
				path[i] = min + matrix[nextvex][i];
		}		//初始点到该点的距离 就更新为 初始点与据点之间的距离 与 据点到该点的距离 之和（上述比较小的那个）
	}

	if (path[to] == 0x3f3f3f3f) {
		cout << -1 << endl;
	}
	else {
		cout << path[to] << endl;
	}

}
int main()
{
	int n, m, v1, v2;
	
	while (scanf_s("%d %d %d %d", &n, &m, &v1, &v2) != EOF)
		Find(n, m, v1, v2);

	return 0;
}
```

# 实验六 并查集 字符串 线段树

## A 字符串处理

空行/空格判定滚出oj！！！！

```c++
#include<bits/stdc++.h>
using namespace std;

string Insert(string s)
{
    //插入字符和位置
    char a;
    int pos;
    cin >> a >> pos;
    s.insert(pos, 1, a);
    cout << "Insert->" << s << endl;
    return s;
}
string Erase(string s)
{
    char c;
    cin >> c;
    for (string::iterator it = s.begin(); it != s.end(); it++)
    {
        if (*it == c)
        {
            s.erase(it);
            it--;
        }
    }
    cout << "Erase->" << s << endl;
    return s;
}
string Replace(string s)
{
    char origin, change;
    cin >> origin >> change;
    replace(s.begin(), s.end(), origin, change);
    cout << "Replace->" << s << endl;
    return s;
}
void Sub(string s)
{
    int i, j;
    cin >> i >> j;
    cout << "Sub->" << s.substr(i, j - i + 1) << endl;
}
void Size(string sr) {
    cout << "Size->" << sr.size() << endl;
}
void Reverse(string sr)
{
    reverse(sr.begin(), sr.end());
    cout << "Reverse->" << sr << endl;
}
int main()
{
    string s;
    int cnt = 1;
    while (cin >> s)
    {
        cout << "Case " << cnt << ":" << endl;
        cnt += 1;
        string si = Insert(s);
        string se = Erase(si);
        string sr = Replace(se);
        Size(sr);
        Reverse(sr);
        Sub(sr);
        string sub;
        cin >> sub;
        int index = sr.find(sub);
  //    cout << "Find->" << index<< endl;
        if (index != sr.npos) {
            cout << "Find->" << index << endl;
        }
        else {
            cout << "Find->" << -1 << endl;
        }
      cout<<endl;
    }
    return 0;
}
```



## B 并查集



```c++
#include<bits/stdc++.h>
using namespace std;

//我也不知道100005有什么含义，但是大家都这么写，我也就跟风了(诚实脸)
//开大点总不会错吧，塔塔开 塔塔开
//根
int root[100005];
//高度
int height[100005];
//每个帮派里的最小人数，也就是要输出的数
int mini = INT_MAX;
//人数，组数
int personNum, groupNum;
//初始化三个变量
void InitSet(int n)
{
	for (int i = 1; i <= n; i++)	
	{
		root[i] = i;
		height[i] = 0;
	}
	mini = INT_MAX;
}
//递归地找到一个帮派的老大
int find(int x)
{
	if (x != root[x]) {
		root[x] = find(root[x]);
	}
    //else不加必错嗷
	else return root[x];
}
//把原来帮派里所有的小弟的归属改成新帮派的老大
void changeRoot(int x, int y)
{
	for (int i = 1; i <= personNum; i++)
	{
		if (root[i] == y) {
			root[i] = x;
		}
	}
}
void Union_Set(int x, int y)
{
    //找到原来帮派里各自的老大
	x = find(x);
	y = find(y);
    //比谁基底深
    //相等，合并入x
	if (height[x] == height[y]) {
		height[x] += 1;
		root[y] = x;
		changeRoot(x, y);
	}
    //不等，小的被大的吞并
	else 
	{
		if (height[x] < height[y]) {
			root[x] = y;
			changeRoot(y, x);
		//	height[y] += 1;
		}
		else {
			root[y] = x;
			changeRoot(x, y);
		//	height[x] += 1;
		}
	}
}
int main()
{
	int n;
	cin >> n;
	while (n--)
	{
		cin >> personNum >> groupNum;
		//初始化根
		InitSet(personNum);
		
		while (groupNum--)
		{
			int person1, person2;
			cin >> person1 >> person2;
            //并查集操作
			Union_Set(person1, person2);
		}
        //求最小的帮派
		int maxNum = root[1], cnt = 1;
		for (int i = 2; i <= personNum; i++)
		{
			if (root[i] == maxNum) {
				cnt += 1;
			}
			else
			{	
				mini = min(cnt, mini);
				cnt = 1;
				maxNum = root[i];
			}
		}
		mini = min(cnt, mini);
		cout << mini << endl;
	}
}
```



## C 字符串处理-相互索引

与map不同，能通过a找到b，也能通过b找到a，类似于无向图。

```c++
#include<bits/stdc++.h>
using namespace std;


int main()
{
	//要求互相索引，所以不采取map的方式，采用结构体对组的方式
	vector<pair<string, string>> dicionary;
	string text;
	//getline接收有空格的字符串
	while (getline(cin, text))
	{
		if (text == "END"){
			break;
		}

		pair<string, string> temp;
		string name, effect;
		int i = 0;
		//获取名字
		for (; text[i] != ']'; i++) {
			name += text[i];
		}
		name += text[i];
		//获取内容
		i += 2;
		for (; i != text.size(); i++){
			effect += text[i];
		}
		temp.first = name;
		temp.second = effect;

		dicionary.push_back(temp);
	}
	int cnt;
	cin >> cnt;
	//接收回车。。好怪哦。。
	getchar();
	for (int i = 0; i < cnt; i++)
	{
		string quo;
		getline(cin, quo);
		//遍历数组，寻找相应字符串
		bool flag = false;
		for (int j = 0; j < dicionary.size(); j++)
		{
			if (dicionary[j].first == quo) 
			{
				cout << dicionary[j].second << endl;
				flag = true;
				break;
			}
			if (dicionary[j].second == quo)
			{
				cout << dicionary[j].first.substr(1, dicionary[j].first.size() - 2) << endl;
				flag = true;
				break;
			}
		}
		//若flag == false说明没找到，输出silence
		if (!flag) {
			cout << "silence" << endl;
		}
	}
	return 0;
}
```

## D trie树

前缀树，抄的，哈希表上学期学了。考试不考！

```c++
#include<bits/stdc++.h>
using namespace std;

struct Trie 
{  
    Trie* next[26];
    int num;    //the number of words prefixed with the current string
    Trie() {   // construction
        for (int i = 0; i < 26; i++) 
            next[i] = NULL;
        num = 0;
    }
};

Trie root;

void Insert(string str)
{    // insert str to the trie
    Trie* p = &root;
    // process every character
    for (int i = 0; str[i]; i++) 
    {    
        if (p->next[str[i] - 'a'] == NULL)    // if the character has no corresponding trie node
            p->next[str[i] - 'a'] = new Trie;    // create the trie node
        p = p->next[str[i] - 'a'];
        p->num++;
    }
}

//return the number of words prefixed with str
int Find(string str)
{   
    Trie* p = &root;
    for (int i = 0; str[i]; i++)
    {    // find the str in the trie
        if (p->next[str[i] - 'a'] == NULL) // find none
            return 0;
        p = p->next[str[i] - 'a'];
    }
    return p->num;
}

int main() {
    string str;
    while (getline(cin, str)) {
        if (str[0] == '\0')
            break;
        Insert(str);
    }
    while (getline(cin, str)) {
        if (Find(str) != 0) {
            cout << "YES" << endl;
        }
        else {
            cout << "NO" << endl;
        }
    }
    return 0;
}
```



## E 线段树单点修改模板题

```c++
#include<stdio.h>
#include<string.h>
#include<algorithm>
#include<bits/stdc++.h>
using namespace std;
const int maxn = 2 * 1e5 + 7;
int a[maxn];
struct stu
{
    int l;
    int r;
    int sum;
}A[maxn * 4];//构建线段树的节点，每个节点包含左右的边界和值；

//线段树的建造
void build(int start, int end, int i)
{
    //确定左右区间
    A[i].l = start;
    A[i].r = end;
    if (start == end)
    {
        A[i].sum = a[start];
        return;
    } 
    //如果左边界等于右边界，就相当于找到了这棵树的最下面，这个时候就可以赋值了；
    //如果没有找到最下面那么就接着往下找，找的时候分成左边的节点和右边的节点；
    int mid = (start + end) / 2;
    build(start, mid, 2 * i);
    build(mid + 1, end, 2 * i + 1);
    //除了最下面的那个节点，其他的每个节点的值都由他下面的两个节点得到
    A[i].sum = A[i * 2].sum + A[i * 2 + 1].sum;

}
//对线段树的维护
void update(int val,int pos, int i, string query)
{
    //如果找到了那个点，就改变他的值
    if (A[i].l == pos && A[i].r == pos)
    {
        if(query == "Add")
            A[i].sum += val;
        else if(query == "Sub")
            A[i].sum -= val;
        return;
    }
    //如果找不到，那么就去此时中间点的值，然后取判断是要从右边找这个点还是要从左边找；                        
    int mid = (A[i].l + A[i].r) / 2;
    if (pos <= mid)
        update(val, pos, i * 2, query);
    else if (pos > mid)
        update(val, pos, 2 * i + 1, query);  
    //找到之后要把这个节点上面的所有的点全部更新;
    A[i].sum = A[i * 2].sum + A[i * 2 + 1].sum;
}
int Query(int start, int end, int i)
{
    //如果此时节点的左右边界被所求区间所包含, 那么就返回此时节点的值；
    if (A[i].l >= start && A[i].r <= end)
        return A[i].sum;

    int mid = (A[i].l + A[i].r) / 2;
    //左子树找
    if (mid >= end)
        return Query(start, end, i * 2);
    //右子树找
    else if (mid < start)
        return Query(start, end, i * 2 + 1);

    return (Query(start, mid, 2 * i) + Query(mid + 1, end, i * 2 + 1));
}


int main()
{
    int t;
    cin >> t;
    int cnt = 1;
    while (t--)
    {
        cout << "Case " << cnt++ << ":" << endl;
        int n;
        cin >> n;
        //初始化大小，原数组
        memset(A, 0, sizeof(A));
        for (int i = 1; i <= n; i++)
            scanf_s("%d", &a[i]);

        build(1, n, 1);
        while (true)
        {
            getchar();
            string str;
            cin >> str;
            if (str == "End") {
                break;
            }
            int i, j;
            cin >> i >> j;

            //1：从根节点往下找，根节点肯定是1
            if (str == "Query"){
                printf("%d\n", Query(i, j, 1));
            }
            else update(i, j, 1, str);
        }
    }
}
```
